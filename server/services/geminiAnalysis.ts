import { GoogleGenAI } from "@google/genai";
import * as fs from "fs";

// Initialize Gemini AI with user's API key
const ai = new GoogleGenAI({ apiKey: process.env.GOOGLE_API_KEY || "" });

// Gemini as ASSISTANT to our SMC Strategy - validates and enhances signals
const SIGNAL_VALIDATION_INSTRUCTION = `Role: You are a technical analysis assistant that validates and enhances Smart Money Concepts (SMC) trading signals.

Your job is to review signals generated by our algorithmic SMC strategy and provide:
1. Validation: Confirm if the signal setup looks valid
2. Confidence adjustment: Suggest if confidence should be higher or lower based on additional context
3. Risk assessment: Identify any concerns or additional confirmations

Key SMC concepts you understand:
- Supply/Demand zones (institutional order blocks)
- Fair Value Gaps (FVG) - price imbalances
- Change of Character (CHoCH) - trend reversals
- Break of Structure (BOS) - trend continuation
- Liquidity sweeps - stop hunts before reversals
- Higher timeframe context (4H/2H for bias, 15M/30M for zones)

CRITICAL VALIDATION RULES:
1. DO NOT TRADE AGAINST THE TREND unless there is a CONFIRMED trend change (CHoCH):
   - If the higher timeframe trend is bullish, only validate BUY signals
   - If the higher timeframe trend is bearish, only validate SELL signals
   - EXCEPTION: A counter-trend signal is ONLY valid if there is a confirmed CHoCH (Change of Character)
   - CHoCH must be clear: Lower Low breaking structure (bullish CHoCH) or Higher High breaking structure (bearish CHoCH)

2. AVOID UNCLEAR MARKETS:
   - Skip signals when price is ranging/choppy with no clear direction
   - Skip signals when there is no clear higher timeframe bias
   - Skip signals when supply/demand zones are overlapping or messy
   - Skip signals when there are conflicting signals on different timeframes
   - If the market structure is unclear, recommend "skip"

You are NOT generating new signals. You are validating signals from our strategy.

Output Format (JSON only):
{
  "validated": true/false,
  "confidenceAdjustment": number (-20 to +20),
  "concerns": ["list of any concerns"],
  "strengths": ["list of signal strengths"],
  "recommendation": "proceed" | "caution" | "skip",
  "reasoning": "brief explanation"
}`;

// Quick market scan instruction for screening
const MARKET_SCAN_INSTRUCTION = `Role: You are a quick market scanner for Smart Money Concepts.
Analyze the price data and identify if there are potential SMC setups forming.
Look for: supply/demand zones, liquidity pools, potential CHoCH, FVGs.

CRITICAL RULES:
1. Only identify setups that ALIGN with the trend direction
2. Counter-trend setups require CONFIRMED CHoCH (Change of Character)
3. If the market is unclear/choppy/ranging, set hasSetup to false
4. Do not identify setups in messy or conflicting market structures

Output Format (JSON only):
{
  "hasSetup": true/false,
  "direction": "BUY" | "SELL" | "NEUTRAL",
  "setupType": "zone_entry" | "choch" | "liquidity_sweep" | "none",
  "keyLevel": number or null,
  "trendDirection": "bullish" | "bearish" | "unclear",
  "marketClarity": "clear" | "moderate" | "unclear",
  "reasoning": "brief explanation"
}`;

export interface SignalValidationResult {
  validated: boolean;
  confidenceAdjustment: number;
  concerns: string[];
  strengths: string[];
  recommendation: 'proceed' | 'caution' | 'skip';
  reasoning: string;
  error?: string;
  isFallback?: boolean; // True ONLY when Gemini is unavailable and we use strategy signal as-is
}

export interface MarketScanResult {
  hasSetup: boolean;
  direction: 'BUY' | 'SELL' | 'NEUTRAL';
  setupType: 'zone_entry' | 'choch' | 'liquidity_sweep' | 'none';
  keyLevel: number | null;
  trendDirection: 'bullish' | 'bearish' | 'unclear';
  marketClarity: 'clear' | 'moderate' | 'unclear';
  reasoning: string;
  error?: string;
}

export interface PriceData {
  symbol: string;
  timeframe: string;
  candles: CandleData[];
}

export interface CandleData {
  date: string;
  open: number;
  high: number;
  low: number;
  close: number;
  volume?: number;
}

export interface SignalToValidate {
  symbol: string;
  direction: 'BUY' | 'SELL';
  entryPrice: number;
  stopLoss: number;
  takeProfit: number;
  confidence: number;
  strategy: string;
  entryType: string;
  reasoning: string;
  zones?: { type: string; top: number; bottom: number }[];
}

// Format price data for Gemini
function formatPriceDataForGemini(priceData: PriceData[]): string {
  return priceData.map(data => {
    const recentCandles = data.candles.slice(-30); // Last 30 candles
    const lastCandle = recentCandles[recentCandles.length - 1];
    return `
=== ${data.symbol} - ${data.timeframe} ===
Current Price: ${lastCandle?.close || 'N/A'}
Last Update: ${lastCandle?.date || 'N/A'}

Recent Candles (newest first):
${recentCandles.reverse().slice(0, 15).map(c => 
  `${c.date}: O:${c.open.toFixed(5)} H:${c.high.toFixed(5)} L:${c.low.toFixed(5)} C:${c.close.toFixed(5)}`
).join('\n')}
`;
  }).join('\n\n');
}

// Format signal for validation
function formatSignalForValidation(signal: SignalToValidate): string {
  let zonesText = '';
  if (signal.zones && signal.zones.length > 0) {
    zonesText = `\nIdentified Zones:\n${signal.zones.map(z => 
      `- ${z.type}: ${z.bottom.toFixed(5)} - ${z.top.toFixed(5)}`
    ).join('\n')}`;
  }

  return `
=== SIGNAL TO VALIDATE ===
Symbol: ${signal.symbol}
Direction: ${signal.direction}
Entry: ${signal.entryPrice.toFixed(5)}
Stop Loss: ${signal.stopLoss.toFixed(5)}
Take Profit: ${signal.takeProfit.toFixed(5)}
Current Confidence: ${signal.confidence}%
Strategy: ${signal.strategy}
Entry Type: ${signal.entryType}
Reasoning: ${signal.reasoning}
${zonesText}
`;
}

/**
 * Validate a signal generated by our SMC strategy
 * Gemini acts as a second opinion to enhance accuracy
 */
export async function validateSignalWithGemini(
  signal: SignalToValidate,
  priceData: PriceData[],
  chartImagePath?: string
): Promise<SignalValidationResult> {
  try {
    const formattedData = formatPriceDataForGemini(priceData);
    const formattedSignal = formatSignalForValidation(signal);
    
    // Build content array
    const contents: any[] = [];
    
    // Add chart image if provided
    if (chartImagePath && fs.existsSync(chartImagePath)) {
      const imageBytes = fs.readFileSync(chartImagePath);
      const mimeType = chartImagePath.endsWith('.png') ? 'image/png' : 'image/jpeg';
      contents.push({
        inlineData: {
          data: imageBytes.toString('base64'),
          mimeType,
        },
      });
    }
    
    contents.push(`
Please validate this trading signal from our SMC strategy:

${formattedSignal}

Price Data Context:
${formattedData}

Provide your validation in the exact JSON format specified.
`);

    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      config: {
        systemInstruction: SIGNAL_VALIDATION_INSTRUCTION,
        responseMimeType: "application/json",
        temperature: 0.3,
        maxOutputTokens: 1024,
      },
      contents,
    });

    const text = response.text;
    if (text) {
      try {
        const result = JSON.parse(text);
        return {
          validated: result.validated ?? false,
          confidenceAdjustment: Math.max(-20, Math.min(20, result.confidenceAdjustment || 0)),
          concerns: result.concerns || [],
          strengths: result.strengths || [],
          recommendation: result.recommendation || 'caution',
          reasoning: result.reasoning || '',
        };
      } catch (parseError) {
        return {
          validated: true,
          confidenceAdjustment: 0,
          concerns: ['Could not parse Gemini response'],
          strengths: [],
          recommendation: 'caution',
          reasoning: 'Validation response was not in expected format',
        };
      }
    }
    
    return {
      validated: false,
      confidenceAdjustment: 0,
      concerns: ['Empty response from Gemini'],
      strengths: [],
      recommendation: 'skip',
      reasoning: 'No validation response received',
    };
  } catch (error) {
    console.error('Gemini validation error:', error);
    // ONLY when Gemini is unavailable (error): fallback to strategy signal as-is
    return {
      validated: true,
      confidenceAdjustment: 0,
      concerns: ['Gemini validation unavailable - using strategy signal as fallback'],
      strengths: [],
      recommendation: 'proceed', // Fallback: proceed with strategy signal
      reasoning: 'Gemini service unavailable - FALLBACK: using strategy signal as-is',
      error: error instanceof Error ? error.message : 'Unknown error',
      isFallback: true, // Flag to indicate this is a fallback response
    };
  }
}

/**
 * Quick market scan to pre-screen instruments
 * Helps identify which markets have potential setups
 */
export async function quickMarketScan(
  symbol: string,
  priceData: PriceData[]
): Promise<MarketScanResult> {
  try {
    const formattedData = formatPriceDataForGemini(priceData);
    
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      config: {
        systemInstruction: MARKET_SCAN_INSTRUCTION,
        responseMimeType: "application/json",
        temperature: 0.3,
        maxOutputTokens: 512,
      },
      contents: `Quick scan for ${symbol}:\n${formattedData}`,
    });

    const text = response.text;
    if (text) {
      try {
        const result = JSON.parse(text);
        return {
          hasSetup: result.hasSetup ?? false,
          direction: result.direction || 'NEUTRAL',
          setupType: result.setupType || 'none',
          keyLevel: result.keyLevel || null,
          trendDirection: result.trendDirection || 'unclear',
          marketClarity: result.marketClarity || 'unclear',
          reasoning: result.reasoning || '',
        };
      } catch {
        return {
          hasSetup: false,
          direction: 'NEUTRAL',
          setupType: 'none',
          keyLevel: null,
          trendDirection: 'unclear',
          marketClarity: 'unclear',
          reasoning: 'Could not parse scan response',
        };
      }
    }
    
    return {
      hasSetup: false,
      direction: 'NEUTRAL',
      setupType: 'none',
      keyLevel: null,
      trendDirection: 'unclear',
      marketClarity: 'unclear',
      reasoning: 'Empty scan response',
    };
  } catch (error) {
    console.error('Quick scan error:', error);
    return {
      hasSetup: false,
      direction: 'NEUTRAL',
      setupType: 'none',
      keyLevel: null,
      trendDirection: 'unclear',
      marketClarity: 'unclear',
      reasoning: 'Scan failed',
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// Check if Gemini API is configured
export function isGeminiConfigured(): boolean {
  return !!process.env.GOOGLE_API_KEY;
}

// Test Gemini connection
export async function testGeminiConnection(): Promise<{ success: boolean; message: string }> {
  if (!isGeminiConfigured()) {
    return { success: false, message: 'GOOGLE_API_KEY not configured' };
  }

  try {
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: "Respond with exactly: 'SMC validation ready'",
    });
    
    const text = response.text || '';
    if (text.toLowerCase().includes('ready')) {
      return { success: true, message: 'Gemini API connected successfully' };
    }
    return { success: true, message: `Gemini responded: ${text.slice(0, 50)}...` };
  } catch (error) {
    return { 
      success: false, 
      message: error instanceof Error ? error.message : 'Connection failed' 
    };
  }
}

// Legacy exports for backward compatibility with routes
export async function analyzeWithGemini(
  symbol: string,
  priceData: PriceData[],
  chartImagePath?: string
): Promise<any> {
  // Convert to validation format
  const dummySignal: SignalToValidate = {
    symbol,
    direction: 'BUY',
    entryPrice: 0,
    stopLoss: 0,
    takeProfit: 0,
    confidence: 50,
    strategy: 'smc',
    entryType: 'analysis_request',
    reasoning: 'Full analysis requested',
  };
  
  const validation = await validateSignalWithGemini(dummySignal, priceData, chartImagePath);
  const scan = await quickMarketScan(symbol, priceData);
  
  return {
    validation,
    marketScan: scan,
    note: 'Use validateSignalWithGemini() to validate specific signals from our SMC strategy',
  };
}

export async function quickAnalyzeWithGemini(
  symbol: string,
  priceData: PriceData[]
): Promise<{ direction: 'BUY' | 'SELL' | 'HOLD'; confidence: number; reasoning: string } | null> {
  const scan = await quickMarketScan(symbol, priceData);
  
  if (scan.error) return null;
  
  return {
    direction: scan.direction === 'NEUTRAL' ? 'HOLD' : scan.direction,
    confidence: scan.hasSetup ? 60 : 30,
    reasoning: scan.reasoning,
  };
}
